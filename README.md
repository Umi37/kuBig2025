# kuBig2025
이 저장소는 고려대 세종캠퍼스에서 C 수업을 할 때 쓰는 저장소입니다.

---

#### 2025-03-04



---

#### 2024-03-05

## 오늘 강의에서 배운 것

# 1. 쉘과 리눅스 명령어 이해하기

**쉘이란?**
- 사용자가 운영체제(OS)와 상호작용 할 수 있도록 해주는 "인터페이스"
- 쉘의 동작 방식 두가지
-   1. CLI(Command line Interface) - 명령어 기반 인터페이스 : bash, zsh, sh, cmd, PowerShell 등
-   2. GUI(Graphical User Interface) - 그래픽 기반 인터페이스 : 파일 탐색기 등
-   _리눅스와 macOS에서는 기본적으로 bash, zsh 같은 쉘을 사용하며, 윈도우는 cmd, PowerSheall을 사용_
-   _쉘을 활용하면, 파일 관리, 프로세스 실행, 스크립트 자동화 등 다양한 작업 효율적으로 수행 가능_

**리눅스 명령어**
- 리눅스 명령어는 크게 쉘 명령어와 외부 명령어 두 가지로 나뉨

- 1. 쉘 명령어
-   $ 쉘 자체에서 제공하는 명령어로, 별도의 실행 파일 없이 쉘이 직접 처리
-   $ 빠르게 실행
-   $ 예시 :   cd (디렉토리 이동)
-              pwd (현재 디렉토리 출력)
-              echo (문자열 출력) 
-              alias (명령어 단축 설정)
-              export (환경 변수 설정)
-              exit (쉘 종료)

-   $ 특징 : 쉘 자체에서 처리하므로 별도 프로세스 생성하지 않음 (실행속도 빠름)

- 2. 외부 명령어
-   $ 리눅스 시스템에 설치된 실행 파일(프로그램)으로 존재하는 명령어
-   $ /bin, /user/bin, /sbin 등의 디렉토리에 저장된 프로그램이 실행
-   $ 예시 :    ls (파일 목록 출력)
-               mkdir (디렉토리 생성)
-               touch (파일 생성)
-               cp (파일 복사)
-               mv (파일 이동)
-               grep (문자열 검색)
-               find (파일 찾기)
-               tar (압축 파일 다루기)
-   $ 특징 : 독립적인 실행 파일로 존재 --- 실행 시 새로운 프로세스를 생성 (상대적으로 느림)
-            쉘이 아닌 커널이 직접 실행

- Oh My Zsh : zsh의 기능을 확장하는 플러그인 및 테마 관리 프레임워크
-             다양한 플러그인과 테마를 제공하여 zsh의 사용성을 향상 시킴


# 2. C언어의 컴파일 과정과 Makefile

**컴파일 과정**
_컴파일은 소스코드를 기계어(바이너리어)로 변환하여 실행 가능한 프로그램을 만드는 과정_

- 1. 전처리 : 전처리기가 동작하여 #include, #define 같은 지시문을 처리 
-             처리 결과 : 전처리된 C코드가 포함된 파일 생성(.i)

- 2. 컴파일 : 전처리된 .i 파일을 어셈블리코드 (.s)파일로 변환

- 3. 어셈블 : 어셈블리 코드(.s) 를 기계어로 된 오브젝트 파일(.o)로 변환

- 4. 링크 : 여러개의 오브젝트 파일을 묶어 **최종 실행 파일(바이너리, a.out)**을 만듬

**Makefile의 사용 이유**
- 여러개의 C 파일을 컴파일 할 때 매번 명령어(gcc, cc)를 입력하기 어려움
- 이를 자동화 하기 위해 사용
- make 실행 : 지정된 규칙에 따라 자동으로 컴파일이 진행됨
- make clean 실행 : 오브젝트 파일과 실행 파일 삭제

# 3. C언어의 데이터 타입

### i. 정수형
- 정수형은 2진수(Binary)로 표현
- 정수 값을 저장
- 크기에 따라 여러 종류 있음
- 종류 : char, short, int, long, long long

### ii. 부동소수형
- 부동소수점은 소수점이 '떠다닌다'는 개념에서 유래됨
- 즉, 소수점 위치가 고정되지 않고 가변적으로 이동하면서 표현됨
- IEEE 754 표준을 사용하여 실수를 2진수로 저장
- 실수는 정수보다 저장 방식이 복잡하며, 정확한 값이 아닌 근사값으로 저장됨
- 종류 : float(4byte), double(8byte)
- _doble은 float보다 크기가 2배 커서 더 높은 정밀도를 제공하기 때문에(상대적으로 느리고), 과학, 금융 등에서 주로 사용_

### iii. 숫자의 음수 표현

**unsigned int란?**

- 부호 없는(음수 없는) 정수형
- 0 또는 양수만 저장
- unsigned int에 음수를 넣으면 큰 양수로 해석되므로 주의!!!

**컴퓨터에서 음수를 저장하는 방법**

- 2의 보수 방식으로 표현

### iiii. n진법과 보수

- n진법이란?
- : 숫자를 표현하는 방법 중 하나
-   한 자리에서 가질 수 있는 숫자의 개수가 n개인 진법
-   - 2진법(0,1 사용)
-   - 4진법(0,1,2,3 사용)
-   - 10진법(0~9 사용)
-   - 16진법(0~9, A~F 사용)

- **n의 보수와 (n-1)의 보수란?**
- 모든 수에는 n의 보수(N's Complement)와 (n-1)의 보수((N-1)'s Complement)가 있음

- **(n-1)의 보수**
- 숫자의 모든 자릿수를 **최댓값(`n-1`)에서 뺀 값**
- 쉽게 말해 **각 자릿수를 반전하는 것** (예: 1을 0으로, 0을 1로 바꿈)

- **n의 보수**
- `(n-1)의 보수`를 구한 후 **1을 더한 값**
- `n의 보수 = n-1의 보수 + 1`

💡 **2진법에서는 `1의 보수(One's Complement)`와 `2의 보수(Two's Complement)`라고 부름!**

# 4. 전처리기와 #include 사용법 정리

- #include에서 < >와 " " 차이
- `#include`는 **헤더 파일을 포함**할 때 사용하는 전처리 지시문
- 헤더 파일을 찾는 방식에 따라 `< >`와 `" "`을 사용

- **✔ `< >` (꺽쇠)**
- 시스템 라이브러리 또는 **표준 라이브러리** 헤더 파일을 포함할 때 사용
- **컴파일러가 지정한 디폴트 폴더(시스템 헤더 경로)에서 파일을 찾음**

- **`" "` (따옴표)**

- **사용자가 만든 헤더 파일**을 포함할 때 사용
- 현재 파일이 있는 **디렉토리(현재 위치)에서 먼저 찾고**, 없으면 `#include < >`와 같은 방식으로 검색


- ### 헤더 파일 중복 포함 문제
- C에서는 **같은 헤더 파일을 중복 포함하면 컴파일 오류가 발생할 수 있음**
- `#include`를 통해 헤더 파일을 여러 번 불러오면, **함수 또는 변수가 중복 정의될 가능성이 있음**
- **해결 방법 : `#pragma once`와 `#ifndef` 같은 전처리기를 이용하여 헤더 파일 중복 방지**
-               같은 헤더파일이 한번만 포함되도록 보장
-               간결하고 속도가 빠르지만, 컴파일러에 따라 지원 여부가 다름

# 함수의 기본 형태

✅ **반환형 + 함수이름 + 매개변수 + 본문 `{}`**

✅ **함수 선언** → 세미콜론(`;`) 필요, 실행 코드 없음

✅ **함수 정의** → 실행 코드 포함, 세미콜론(`;`) 없음

✅ `main()` 함수는 프로그램의 시작점이며, `return 0;`으로 정상 종료를 알림

✅ **세미콜론(`;`)은 문장이 끝났음을 나타내는 약속**

# void

**`void`를 사용하는 이유**

- 잘 모르겠음. 나중에 다시 정리 요망!!!!

# void와 int의 차이

- int : 정수 값 반환
- void : 반환 값 없음 (호출 후 값을 저장할 수 없음)

## main(void)
- "이 main 함수는 매개변수를 받지 않는다" 라는 의미
- C 프로그램의 실행은 main() 함수에서 시작됨
- 즉, Entry Point!!
- int main(void) 를 명시적으로 쓰면 매개 변수가 없음을 확실히 표현 


